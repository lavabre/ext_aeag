// ============================================================================
//
// Copyright (c) 2005-2009, Talend Inc.
//
// This source code has been automatically generated by Talend Open Studio
// / JobDesigner (CodeGenerator version 4.0.2.r43696).
// Vous pouvez trouver plus d'informations sur les produits Talend sur www.talend.com.
// Vous pouvez distribuer ce code sous les termes de la licence GNU LGPL
// (http://www.gnu.org/licenses/lgpl.html).
//
// ============================================================================ 
package ext_gac_import.transfertfichier_0_1;

import routines.DataOperation;
import routines.Mathematical;
import routines.Numeric;
import routines.Relational;
import routines.StringHandling;
import routines.TalendDataGenerator;
import routines.TalendDate;
import routines.TalendString;
import routines.system.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.math.BigDecimal;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import java.util.Comparator;

/**
 * Job: TransfertFichier Purpose: <br>
 * Description: <br>
 * 
 * @author jerome.carre@eau-adour-garonne.fr
 * @version 4.0.2.r43696
 * @status
 */
public class TransfertFichier {

	public final Object obj = new Object();

	private final static String defaultCharset = java.nio.charset.Charset
			.defaultCharset().name();

	private final static String utf8Charset = "UTF-8";

	// create and load default properties
	private java.util.Properties defaultProps = new java.util.Properties();

	// create application properties with default
	public class ContextProperties extends java.util.Properties {

		public ContextProperties(java.util.Properties properties) {
			super(properties);
		}

		public ContextProperties() {
			super();
		}

		public void synchronizeContext() {

			if (repertoireEntree != null) {

				this.setProperty("repertoireEntree", repertoireEntree
						.toString());

			}

			if (repertoireSortie != null) {

				this.setProperty("repertoireSortie", repertoireSortie
						.toString());

			}

			if (fichierEntree != null) {

				this.setProperty("fichierEntree", fichierEntree.toString());

			}

			if (fichierSortie != null) {

				this.setProperty("fichierSortie", fichierSortie.toString());

			}

		}

		public String repertoireEntree;

		public String getRepertoireEntree() {
			return this.repertoireEntree;
		}

		public String repertoireSortie;

		public String getRepertoireSortie() {
			return this.repertoireSortie;
		}

		public String fichierEntree;

		public String getFichierEntree() {
			return this.fichierEntree;
		}

		public String fichierSortie;

		public String getFichierSortie() {
			return this.fichierSortie;
		}
	}

	private ContextProperties context = new ContextProperties();

	public ContextProperties getContext() {
		return this.context;
	}

	private final String jobVersion = "0.1";
	private final String jobName = "TransfertFichier";
	private final String projectName = "EXT_GAC_IMPORT";
	public Integer errorCode = null;
	private String currentComponent = "";
	private final java.util.Map<String, Long> start_Hash = new java.util.HashMap<String, Long>();
	private final java.util.Map<String, Long> end_Hash = new java.util.HashMap<String, Long>();
	private final java.util.Map<String, Boolean> ok_Hash = new java.util.HashMap<String, Boolean>();
	private final java.util.Map<String, Object> globalMap = new java.util.HashMap<String, Object>();
	public final java.util.List<String[]> globalBuffer = new java.util.ArrayList<String[]>();

	private final java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
	private final java.io.PrintStream errorMessagePS = new java.io.PrintStream(
			new java.io.BufferedOutputStream(baos));

	public String getExceptionStackTrace() {
		errorMessagePS.flush();
		return baos.toString();
	}

	private class TalendException extends Exception {
		private java.util.Map<String, Object> globalMap = null;
		private Exception e = null;
		private String currentComponent = null;

		private TalendException(Exception e, String errorComponent,
				final java.util.Map<String, Object> globalMap) {
			this.currentComponent = errorComponent;
			this.globalMap = globalMap;
			this.e = e;
		}

		@Override
		public void printStackTrace() {
			if (!(e instanceof TalendException || e instanceof TDieException)) {
				globalMap.put(currentComponent + "_ERROR_MESSAGE", e
						.getMessage());
				System.err
						.println("Exception in component " + currentComponent);
			}
			if (!(e instanceof TDieException)) {
				if (e instanceof TalendException) {
					e.printStackTrace();
				} else {
					e.printStackTrace();
					e.printStackTrace(errorMessagePS);
				}
			}
			if (!(e instanceof TalendException)) {
				try {
					for (java.lang.reflect.Method m : this.getClass()
							.getEnclosingClass().getMethods()) {
						if (m.getName().compareTo(currentComponent + "_error") == 0) {
							m.invoke(TransfertFichier.this, new Object[] { e,
									currentComponent, globalMap });
							break;
						}
					}

					if (!(e instanceof TDieException)) {
					}
				} catch (java.lang.SecurityException e) {
					this.e.printStackTrace();
				} catch (java.lang.IllegalArgumentException e) {
					this.e.printStackTrace();
				} catch (java.lang.IllegalAccessException e) {
					this.e.printStackTrace();
				} catch (java.lang.reflect.InvocationTargetException e) {
					this.e.printStackTrace();
				}
			}
		}
	}

	public void tPrejob_1_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tPrejob_1", System.currentTimeMillis());
		tPrejob_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tFileList_1_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tFileList_1", System.currentTimeMillis());
		tFileList_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tFTPPut_1_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tFTPPut_1", System.currentTimeMillis());
		tFileList_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tPostjob_1_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tPostjob_1", System.currentTimeMillis());
		tPostjob_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tMsgBox_1_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tMsgBox_1", System.currentTimeMillis());
		tMsgBox_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tPrejob_1_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception), "");

	}

	public void tFileList_1_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception), "");

	}

	public void tPostjob_1_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception), "");

	}

	public void tMsgBox_1_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception), "");

	}

	public void tPrejob_1Process(final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tPrejob_1_SUBPROCESS_STATE", 0);

		final boolean execStat = this.execStat;

		String iterateId = "";
		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume
				globalResumeTicket = true;

				/**
				 * [tPrejob_1 begin ] start
				 */

				ok_Hash.put("tPrejob_1", false);
				start_Hash.put("tPrejob_1", System.currentTimeMillis());
				currentComponent = "tPrejob_1";

				int tos_count_tPrejob_1 = 0;

				/**
				 * [tPrejob_1 begin ] stop
				 */
				/**
				 * [tPrejob_1 main ] start
				 */

				currentComponent = "tPrejob_1";

				tos_count_tPrejob_1++;

				/**
				 * [tPrejob_1 main ] stop
				 */
				/**
				 * [tPrejob_1 end ] start
				 */

				currentComponent = "tPrejob_1";

				ok_Hash.put("tPrejob_1", true);
				end_Hash.put("tPrejob_1", System.currentTimeMillis());

				tFileList_1Process(globalMap);

				/**
				 * [tPrejob_1 end ] stop
				 */

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		}

		globalMap.put("tPrejob_1_SUBPROCESS_STATE", 1);
	}

	public void tFileList_1Process(final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tFileList_1_SUBPROCESS_STATE", 0);

		final boolean execStat = this.execStat;

		String iterateId = "";
		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume
				globalResumeTicket = true;

				/**
				 * [tFileList_1 begin ] start
				 */

				int NB_ITERATE_tFTPPut_1 = 0; // for statistics

				ok_Hash.put("tFileList_1", false);
				start_Hash.put("tFileList_1", System.currentTimeMillis());
				currentComponent = "tFileList_1";

				int tos_count_tFileList_1 = 0;
				// tFileList_Begin

				String directory_tFileList_1 = context.repertoireEntree;

				java.util.List<String> maskList_tFileList_1 = new java.util.ArrayList<String>();

				maskList_tFileList_1.add("*.txt");

				int NB_FILEtFileList_1 = 0;
				for (String filemask_tFileList_1 : maskList_tFileList_1) {

					filemask_tFileList_1 = org.apache.oro.text.GlobCompiler
							.globToPerl5(
									filemask_tFileList_1.toCharArray(),
									org.apache.oro.text.GlobCompiler.DEFAULT_MASK);

					boolean case_sensitive_tFileList_1 = true;
					java.util.regex.Pattern fileNamePattern_tFileList_1 = java.util.regex.Pattern
							.compile(filemask_tFileList_1);
					if (!case_sensitive_tFileList_1) {
						fileNamePattern_tFileList_1 = java.util.regex.Pattern
								.compile(
										filemask_tFileList_1,
										java.util.regex.Pattern.CASE_INSENSITIVE);
					}
					java.io.File file_tFileList_1 = new java.io.File(
							directory_tFileList_1);
					final java.util.List<java.io.File> list_tFileList_1 = new java.util.ArrayList<java.io.File>();
					file_tFileList_1.listFiles(new java.io.FilenameFilter() {
						public boolean accept(java.io.File dir, String name) {
							java.io.File file = new java.io.File(dir, name);
							if (!file.isDirectory()) {
								list_tFileList_1.add(file);
							}
							return true;
						}
					});
					// int NB_FILEtFileList_1 = 0;
					java.io.File[] tempArray_tFileList_1 = list_tFileList_1
							.toArray(new java.io.File[list_tFileList_1.size()]);
					java.util.Arrays.sort(tempArray_tFileList_1);

					java.util.List<java.io.File> fileList_tFileList_1 = new java.util.ArrayList<java.io.File>();

					fileList_tFileList_1 = java.util.Arrays
							.asList(tempArray_tFileList_1);

					for (int i_tFileList_1 = 0; i_tFileList_1 < fileList_tFileList_1
							.size(); i_tFileList_1++) {

						java.io.File files_tFileList_1 = fileList_tFileList_1
								.get(i_tFileList_1);
						String fileName_tFileList_1 = files_tFileList_1
								.getName();
						if (!fileNamePattern_tFileList_1.matcher(
								fileName_tFileList_1).matches()) {
							continue;
						}

						String currentFileName_tFileList_1 = files_tFileList_1
								.getName();
						String currentFilePath_tFileList_1 = files_tFileList_1
								.getAbsolutePath();
						String currentFileDirectory_tFileList_1 = files_tFileList_1
								.getParent();
						String currentFileExtension_tFileList_1 = null;
						if (files_tFileList_1.getName().contains(".")
								&& files_tFileList_1.isFile()) {
							currentFileExtension_tFileList_1 = files_tFileList_1
									.getName().substring(
											files_tFileList_1.getName()
													.lastIndexOf(".") + 1);
						} else {
							currentFileExtension_tFileList_1 = "";
						}
						NB_FILEtFileList_1++;

						globalMap.put("tFileList_1_CURRENT_FILE",
								currentFileName_tFileList_1);
						globalMap.put("tFileList_1_CURRENT_FILEPATH",
								currentFilePath_tFileList_1);
						globalMap.put("tFileList_1_CURRENT_FILEDIRECTORY",
								currentFileDirectory_tFileList_1);
						globalMap.put("tFileList_1_CURRENT_FILEEXTENSION",
								currentFileExtension_tFileList_1);
						globalMap
								.put("tFileList_1_NB_FILE", NB_FILEtFileList_1);

						/**
						 * [tFileList_1 begin ] stop
						 */
						/**
						 * [tFileList_1 main ] start
						 */

						currentComponent = "tFileList_1";

						tos_count_tFileList_1++;

						/**
						 * [tFileList_1 main ] stop
						 */
						NB_ITERATE_tFTPPut_1++;

						/**
						 * [tFTPPut_1 begin ] start
						 */

						ok_Hash.put("tFTPPut_1", false);
						start_Hash.put("tFTPPut_1", System.currentTimeMillis());
						currentComponent = "tFTPPut_1";

						int tos_count_tFTPPut_1 = 0;

						int nb_file_tFTPPut_1 = 0;

						com.enterprisedt.net.ftp.FTPClient ftp_tFTPPut_1 = null;

						ftp_tFTPPut_1 = new com.enterprisedt.net.ftp.FTPClient();
						ftp_tFTPPut_1.setRemoteHost("172.30.10.2");
						ftp_tFTPPut_1.setRemotePort(21);
						ftp_tFTPPut_1
								.setConnectMode(com.enterprisedt.net.ftp.FTPConnectMode.PASV);
						ftp_tFTPPut_1.setControlEncoding("ISO-8859-15");
						ftp_tFTPPut_1.connect();
						ftp_tFTPPut_1.login("ftpadmin", "pulp31");

						// msg_tFTPPut_1 likes a String[] to save the message
						// from transfer.
						com.enterprisedt.net.ftp.TransferCompleteStrings msg_tFTPPut_1 = ftp_tFTPPut_1
								.getTransferCompleteMessages();
						msg_tFTPPut_1.clearAll();

						java.util.List<java.util.Map<String, String>> listtFTPPut_1 = new java.util.ArrayList<java.util.Map<String, String>>();
						java.util.Map<String, String> maptFTPPut_10 = new java.util.HashMap<String, String>();
						maptFTPPut_10.put(((String) globalMap
								.get("tFileList_1_CURRENT_FILE")), "");
						listtFTPPut_1.add(maptFTPPut_10);
						String remotedirtFTPPut_1 = context.repertoireSortie;
						ftp_tFTPPut_1.chdir(remotedirtFTPPut_1);

						ftp_tFTPPut_1
								.setType(com.enterprisedt.net.ftp.FTPTransferType.BINARY);
						String localdirtFTPPut_1 = context.repertoireEntree;
						for (java.util.Map<String, String> maptFTPPut_1 : listtFTPPut_1) {

							/**
							 * [tFTPPut_1 begin ] stop
							 */
							/**
							 * [tFTPPut_1 main ] start
							 */

							currentComponent = "tFTPPut_1";

							try {

								String currentStatus_tFTPPut_1 = "No file transfered.";
								java.util.Set<String> keySettFTPPut_1 = maptFTPPut_1
										.keySet();
								for (String keytFTPPut_1 : keySettFTPPut_1) {
									String tempdirtFTPPut_1 = localdirtFTPPut_1;
									String filemasktFTPPut_1 = keytFTPPut_1;
									String dirtFTPPut_1 = null;
									String masktFTPPut_1 = filemasktFTPPut_1
											.replaceAll("\\\\", "/");
									int itFTPPut_1 = masktFTPPut_1
											.lastIndexOf('/');
									if (itFTPPut_1 != -1) {
										dirtFTPPut_1 = masktFTPPut_1.substring(
												0, itFTPPut_1);
										masktFTPPut_1 = masktFTPPut_1
												.substring(itFTPPut_1 + 1);
									}
									if (dirtFTPPut_1 != null
											&& !"".equals(dirtFTPPut_1))
										tempdirtFTPPut_1 = tempdirtFTPPut_1
												+ "/" + dirtFTPPut_1;
									masktFTPPut_1 = masktFTPPut_1.replaceAll(
											"\\.", "\\\\.").replaceAll("\\*",
											".*");
									final String finalMasktFTPPut_1 = masktFTPPut_1;
									java.io.File[] listingstFTPPut_1 = null;
									java.io.File filetFTPPut_1 = new java.io.File(
											tempdirtFTPPut_1);
									if (filetFTPPut_1.isDirectory()) {
										listingstFTPPut_1 = filetFTPPut_1
												.listFiles(new java.io.FileFilter() {
													public boolean accept(
															java.io.File pathname) {
														boolean result = false;
														if (pathname != null
																&& pathname
																		.isFile()) {
															result = java.util.regex.Pattern
																	.compile(
																			finalMasktFTPPut_1)
																	.matcher(
																			pathname
																					.getName())
																	.find();
														}
														return result;
													}
												});
									}
									java.util.List<String> remoteExistsFiles_tFTPPut_1 = new java.util.ArrayList<String>();

									com.enterprisedt.net.ftp.FTPFile[] ftpFiles_tFTPPut_1 = ftp_tFTPPut_1
											.dirDetails(".");
									for (com.enterprisedt.net.ftp.FTPFile ftpFile : ftpFiles_tFTPPut_1) {
										if (!ftpFile.isDir()
												&& !ftpFile.isLink()) {
											if ("".equals(maptFTPPut_1
													.get(keytFTPPut_1))) {
												if (ftpFile.getName().matches(
														masktFTPPut_1)) {
													remoteExistsFiles_tFTPPut_1
															.add(ftpFile
																	.getName());
												}
											} else {
												if (ftpFile
														.getName()
														.matches(
																maptFTPPut_1
																		.get(keytFTPPut_1))) {
													remoteExistsFiles_tFTPPut_1
															.add(ftpFile
																	.getName());
												}
											}
										}
									}

									if (listingstFTPPut_1 != null
											&& listingstFTPPut_1.length > 0) {
										for (int mtFTPPut_1 = 0; mtFTPPut_1 < listingstFTPPut_1.length; mtFTPPut_1++) {
											try {
												if (listingstFTPPut_1[mtFTPPut_1]
														.getName().matches(
																masktFTPPut_1)) {
													java.io.File file_in_localDir = listingstFTPPut_1[mtFTPPut_1];
													globalMap
															.put(
																	"tFTPPut_1_CURRENT_FILE_EXISTS",
																	remoteExistsFiles_tFTPPut_1
																			.contains(file_in_localDir
																					.getName()));
													String newName_tFTPPut_1 = (""
															.equals(maptFTPPut_1
																	.get(keytFTPPut_1))) ? file_in_localDir
															.getName()
															: maptFTPPut_1
																	.get(keytFTPPut_1);

													if (!(remoteExistsFiles_tFTPPut_1
															.contains(newName_tFTPPut_1))) {
														ftp_tFTPPut_1
																.put(
																		tempdirtFTPPut_1
																				+ "/"
																				+ file_in_localDir
																						.getName(),
																		newName_tFTPPut_1);

														// add uploading status
														// to list which will
														// return back to
														// client.
														msg_tFTPPut_1
																.add("file: "
																		+ file_in_localDir
																				.getAbsolutePath()
																		+ ", size: "
																		+ file_in_localDir
																				.length()
																		+ " bytes upload successfully");

														currentStatus_tFTPPut_1 = "File rename OK.";
														globalMap
																.put(
																		"tFTPPut_1_CURRENT_FILE_EXISTS",
																		remoteExistsFiles_tFTPPut_1
																				.contains(newName_tFTPPut_1));
													}

													nb_file_tFTPPut_1++;
												}
											} catch (com.enterprisedt.net.ftp.FTPException e) {

												msg_tFTPPut_1
														.add("file "
																+ listingstFTPPut_1[mtFTPPut_1]
																		.getAbsolutePath()
																+ " not found?");

												currentStatus_tFTPPut_1 = "File rename fail.";
												globalMap
														.put(
																"tFTPPut_1_CURRENT_FILE_EXISTS",
																remoteExistsFiles_tFTPPut_1
																		.contains(listingstFTPPut_1[mtFTPPut_1]
																				.getName()));

												throw e;
											}
										}
									} else {
										System.err
												.println("No match file exist!");
									}

								}
								globalMap.put("tFTPPut_1_CURRENT_STATUS",
										currentStatus_tFTPPut_1);

							} catch (Exception e) {
								throw (e);
							}

							tos_count_tFTPPut_1++;

							/**
							 * [tFTPPut_1 main ] stop
							 */
							/**
							 * [tFTPPut_1 end ] start
							 */

							currentComponent = "tFTPPut_1";

						}

						msg_tFTPPut_1.add(ftp_tFTPPut_1.getUploadCount()
								+ " files have been uploaded.");

						String[] msgAll_tFTPPut_1 = msg_tFTPPut_1.getAll();
						StringBuffer sb_tFTPPut_1 = new StringBuffer();
						if (msgAll_tFTPPut_1 != null) {
							for (String item_tFTPPut_1 : msgAll_tFTPPut_1) {
								sb_tFTPPut_1.append(item_tFTPPut_1)
										.append("\n");
							}
						}
						globalMap.put("tFTPPut_1_TRANSFER_MESSAGES",
								sb_tFTPPut_1.toString());

						ftp_tFTPPut_1.quit();

						globalMap.put("tFTPPut_1_NB_FILE", nb_file_tFTPPut_1);

						ok_Hash.put("tFTPPut_1", true);
						end_Hash.put("tFTPPut_1", System.currentTimeMillis());

						/**
						 * [tFTPPut_1 end ] stop
						 */

						/**
						 * [tFileList_1 end ] start
						 */

						currentComponent = "tFileList_1";

					}
				}

				globalMap.put("tFileList_1_NB_FILE", NB_FILEtFileList_1);

				ok_Hash.put("tFileList_1", true);
				end_Hash.put("tFileList_1", System.currentTimeMillis());

				/**
				 * [tFileList_1 end ] stop
				 */

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		}

		globalMap.put("tFileList_1_SUBPROCESS_STATE", 1);
	}

	public void tPostjob_1Process(final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tPostjob_1_SUBPROCESS_STATE", 0);

		final boolean execStat = this.execStat;

		String iterateId = "";
		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume
				globalResumeTicket = true;

				/**
				 * [tPostjob_1 begin ] start
				 */

				ok_Hash.put("tPostjob_1", false);
				start_Hash.put("tPostjob_1", System.currentTimeMillis());
				currentComponent = "tPostjob_1";

				int tos_count_tPostjob_1 = 0;

				/**
				 * [tPostjob_1 begin ] stop
				 */
				/**
				 * [tPostjob_1 main ] start
				 */

				currentComponent = "tPostjob_1";

				tos_count_tPostjob_1++;

				/**
				 * [tPostjob_1 main ] stop
				 */
				/**
				 * [tPostjob_1 end ] start
				 */

				currentComponent = "tPostjob_1";

				ok_Hash.put("tPostjob_1", true);
				end_Hash.put("tPostjob_1", System.currentTimeMillis());

				tMsgBox_1Process(globalMap);

				/**
				 * [tPostjob_1 end ] stop
				 */

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		}

		globalMap.put("tPostjob_1_SUBPROCESS_STATE", 1);
	}

	public void tMsgBox_1Process(final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tMsgBox_1_SUBPROCESS_STATE", 0);

		final boolean execStat = this.execStat;

		String iterateId = "";
		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume
				globalResumeTicket = true;

				/**
				 * [tMsgBox_1 begin ] start
				 */

				ok_Hash.put("tMsgBox_1", false);
				start_Hash.put("tMsgBox_1", System.currentTimeMillis());
				currentComponent = "tMsgBox_1";

				int tos_count_tMsgBox_1 = 0;

				/**
				 * [tMsgBox_1 begin ] stop
				 */
				/**
				 * [tMsgBox_1 main ] start
				 */

				currentComponent = "tMsgBox_1";

				int messageIcontMsgBox_1 = javax.swing.JOptionPane.INFORMATION_MESSAGE;
				String titletMsgBox_1 = "Transfert des fichiers vers le répertoire :  "
						+ context.repertoireSortie;
				String messagetMsgBox_1 = "Transfert des fichiers vers le répertoire :  "
						+ context.repertoireSortie + " terminés !";
				String resulttMsgBox_1 = null;

				javax.swing.JOptionPane.showMessageDialog(null,
						messagetMsgBox_1, titletMsgBox_1, messageIcontMsgBox_1);
				resulttMsgBox_1 = String.valueOf(1);

				globalMap.put("tMsgBox_1_RESULT", resulttMsgBox_1);

				tos_count_tMsgBox_1++;

				/**
				 * [tMsgBox_1 main ] stop
				 */
				/**
				 * [tMsgBox_1 end ] start
				 */

				currentComponent = "tMsgBox_1";

				ok_Hash.put("tMsgBox_1", true);
				end_Hash.put("tMsgBox_1", System.currentTimeMillis());

				/**
				 * [tMsgBox_1 end ] stop
				 */

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		}

		globalMap.put("tMsgBox_1_SUBPROCESS_STATE", 1);
	}

	public String resuming_logs_dir_path = null;
	public String resuming_checkpoint_path = null;
	public String parent_part_launcher = null;
	private String resumeEntryMethodName = null;
	private boolean globalResumeTicket = false;

	public boolean watch = false;
	// portStats is null, it means don't execute the statistics
	public Integer portStats = null;
	public int portTraces = 4334;
	public String clientHost;
	public String defaultClientHost = "localhost";
	public String contextStr = "Default";
	public String pid = "0";
	public String rootPid = null;
	public String fatherPid = null;
	public String fatherNode = null;
	public long startTime = 0;
	public boolean isChildJob = false;

	private boolean execStat = true;

	private ThreadLocal threadLocal = new ThreadLocal();
	{
		java.util.Map threadRunResultMap = new java.util.HashMap();
		threadRunResultMap.put("errorCode", null);
		threadRunResultMap.put("status", "");
		threadLocal.set(threadRunResultMap);
	}

	private java.util.Properties context_param = new java.util.Properties();
	public java.util.Map<String, Object> parentContextMap = new java.util.HashMap<String, Object>();

	public String status = "";

	public static void main(String[] args) {
		final TransfertFichier TransfertFichierClass = new TransfertFichier();

		int exitCode = TransfertFichierClass.runJobInTOS(args);

		System.exit(exitCode);
	}

	public String[][] runJob(String[] args) {

		int exitCode = runJobInTOS(args);
		String[][] bufferValue = new String[][] { { Integer.toString(exitCode) } };

		return bufferValue;
	}

	public int runJobInTOS(String[] args) {

		String lastStr = "";
		for (String arg : args) {
			if (arg.equalsIgnoreCase("--context_param")) {
				lastStr = arg;
			} else if (lastStr.equals("")) {
				evalParam(arg);
			} else {
				evalParam(lastStr + " " + arg);
				lastStr = "";
			}
		}

		if (clientHost == null) {
			clientHost = defaultClientHost;
		}

		if (pid == null || "0".equals(pid)) {
			pid = TalendString.getAsciiRandomString(6);
		}

		if (rootPid == null) {
			rootPid = pid;
		}
		if (fatherPid == null) {
			fatherPid = pid;
		} else {
			isChildJob = true;
		}

		try {
			// call job/subjob with an existing context, like:
			// --context=production. if without this parameter, there will use
			// the default context instead.
			java.io.InputStream inContext = TransfertFichier.class
					.getClassLoader().getResourceAsStream(
							"ext_gac_import/transfertfichier_0_1/contexts/"
									+ contextStr + ".properties");
			if (inContext != null) {
				// defaultProps is in order to keep the original context value
				defaultProps.load(inContext);
				inContext.close();
				context = new ContextProperties(defaultProps);
			} else {
				// print info and job continue to run, for case: context_param
				// is not empty.
				System.err.println("Could not find the context " + contextStr);
			}

			if (!context_param.isEmpty()) {
				context.putAll(context_param);
			}

			context.repertoireEntree = (String) context
					.getProperty("repertoireEntree");

			context.repertoireSortie = (String) context
					.getProperty("repertoireSortie");

			context.fichierEntree = (String) context
					.getProperty("fichierEntree");

			context.fichierSortie = (String) context
					.getProperty("fichierSortie");

		} catch (java.io.IOException ie) {
			System.err.println("Could not load context " + contextStr);
			ie.printStackTrace();
		}

		// get context value from parent directly
		if (parentContextMap != null && !parentContextMap.isEmpty()) {
			if (parentContextMap.containsKey("repertoireEntree")) {
				context.repertoireEntree = (String) parentContextMap
						.get("repertoireEntree");
			}
			if (parentContextMap.containsKey("repertoireSortie")) {
				context.repertoireSortie = (String) parentContextMap
						.get("repertoireSortie");
			}
			if (parentContextMap.containsKey("fichierEntree")) {
				context.fichierEntree = (String) parentContextMap
						.get("fichierEntree");
			}
			if (parentContextMap.containsKey("fichierSortie")) {
				context.fichierSortie = (String) parentContextMap
						.get("fichierSortie");
			}
		}

		// Resume: init the resumeUtil
		resumeEntryMethodName = ResumeUtil
				.getResumeEntryMethodName(resuming_checkpoint_path);
		resumeUtil = new ResumeUtil(resuming_logs_dir_path, isChildJob, rootPid);
		resumeUtil.initCommonInfo(pid, rootPid, fatherPid, projectName,
				jobName, contextStr, jobVersion);

		// Resume: jobStart
		resumeUtil.addLog("JOB_STARTED", "JOB:" + jobName,
				parent_part_launcher, Thread.currentThread().getId() + "", "",
				"", "", "", resumeUtil.convertToJsonText(context));

		long startUsedMemory = Runtime.getRuntime().totalMemory()
				- Runtime.getRuntime().freeMemory();
		long endUsedMemory = 0;
		long end = 0;

		startTime = System.currentTimeMillis();

		this.globalResumeTicket = true;// to run tPreJob

		try {
			errorCode = null;
			tPrejob_1Process(globalMap);
			status = "end";
		} catch (TalendException e_tPrejob_1) {
			status = "failure";
			e_tPrejob_1.printStackTrace();
			globalMap.put("tPrejob_1_SUBPROCESS_STATE", -1);

		} finally {
		}

		this.globalResumeTicket = false;// to run others jobs

		this.globalResumeTicket = true;// to run tPostJob

		try {
			errorCode = null;
			tPostjob_1Process(globalMap);
			status = "end";
		} catch (TalendException e_tPostjob_1) {
			status = "failure";
			e_tPostjob_1.printStackTrace();
			globalMap.put("tPostjob_1_SUBPROCESS_STATE", -1);

		} finally {
		}
		end = System.currentTimeMillis();

		if (watch) {
			System.out.println((end - startTime) + " milliseconds");
		}

		endUsedMemory = Runtime.getRuntime().totalMemory()
				- Runtime.getRuntime().freeMemory();
		if (false) {
			System.out.println((endUsedMemory - startUsedMemory)
					+ " bytes memory increase when running : TransfertFichier");
		}

		resumeUtil.addLog("JOB_ENDED", "JOB:" + jobName, parent_part_launcher,
				Thread.currentThread().getId() + "", "", "", "", "", "");

		if (errorCode == null) {
			return status != null && status.equals("failure") ? 1 : 0;
		} else {
			return errorCode.intValue();
		}
	}

	private void evalParam(String arg) {
		if (arg.startsWith("--resuming_logs_dir_path")) {
			resuming_logs_dir_path = arg.substring(25);
		} else if (arg.startsWith("--resuming_checkpoint_path")) {
			resuming_checkpoint_path = arg.substring(27);
		} else if (arg.startsWith("--parent_part_launcher")) {
			parent_part_launcher = arg.substring(23);
		} else if (arg.startsWith("--watch")) {
			watch = true;
		} else if (arg.startsWith("--stat_port=")) {
			String portStatsStr = arg.substring(12);
			if (portStatsStr != null && !portStatsStr.equals("null")) {
				portStats = Integer.parseInt(portStatsStr);
			}
		} else if (arg.startsWith("--trace_port=")) {
			portTraces = Integer.parseInt(arg.substring(13));
		} else if (arg.startsWith("--client_host=")) {
			clientHost = arg.substring(14);
		} else if (arg.startsWith("--context=")) {
			contextStr = arg.substring(10);
		} else if (arg.startsWith("--father_pid=")) {
			fatherPid = arg.substring(13);
		} else if (arg.startsWith("--root_pid=")) {
			rootPid = arg.substring(11);
		} else if (arg.startsWith("--father_node=")) {
			fatherNode = arg.substring(14);
		} else if (arg.startsWith("--pid=")) {
			pid = arg.substring(6);
		} else if (arg.startsWith("--context_param")) {
			String keyValue = arg.substring(16);
			int index = -1;
			if (keyValue != null && (index = keyValue.indexOf('=')) > -1) {
				context_param.put(keyValue.substring(0, index), keyValue
						.substring(index + 1));
			}
		}

	}

	public Integer getErrorCode() {
		return errorCode;
	}

	public String getStatus() {
		return status;
	}

	ResumeUtil resumeUtil = null;
}
/************************************************************************************************
 * 33684 characters generated by Talend Open Studio on the 17 décembre 2012
 * 14:26:15 CET
 ************************************************************************************************/
